{:tasks
 {;; Docker environment tasks
  :requires ([babashka.process :as p]
             [clojure.string :as str])

  docker:start
  {:doc "Start test database environment"
   :task (do
           (println "🚀 Starting test databases...")
           (p/shell "docker-compose up -d postgres mysql redis minio")
           (println "\n⏳ Waiting for databases to be healthy...")
           (Thread/sleep 5000)
           (println "\n✅ Databases started!")
           (println "\nConnection details:")
           (println "  PostgreSQL: localhost:5432 (postgres/postgres)")
           (println "  MySQL:      localhost:3306 (root/password)")
           (println "  Redis:      localhost:6379")
           (println "  MinIO S3:   http://localhost:9000 (minioadmin/minioadmin)")
           (println "\n💡 Run 'bb docker:status' to check health"))}

  docker:stop
  {:doc "Stop test database environment"
   :task (do
           (println "Stopping test databases...")
           (p/shell "docker-compose down")
           (println "✅ Databases stopped"))}

  docker:restart
  {:doc "Restart test database environment"
   :task (do
           (run 'docker:stop)
           (Thread/sleep 2000)
           (run 'docker:start))}

  docker:reset
  {:doc "Reset databases (removes all data)"
   :task (do
           (println "⚠️  This will delete all test data!")
           (print "Continue? (y/N): ")
           (flush)
           (let [input (str/lower-case (read-line))]
             (if (= input "y")
               (do
                 (println "\n🗑️  Removing containers and volumes...")
                 (p/shell "docker-compose down -v")
                 (Thread/sleep 2000)
                 (run 'docker:start))
               (println "Cancelled."))))}

  docker:status
  {:doc "Check status of test databases"
   :task (do
           (println "📊 Database Status\n==================\n")
           (p/shell "docker-compose ps")
           (println "\n💡 Commands:")
           (println "  bb docker:start   - Start databases")
           (println "  bb docker:stop    - Stop databases")
           (println "  bb docker:restart - Restart databases")
           (println "  bb docker:reset   - Reset (delete all data)")
           (println "  bb docker:logs    - View logs"))}

  docker:logs
  {:doc "View database logs"
   :task (p/shell "docker-compose logs -f")}

  docker:tools
  {:doc "Start database admin tools"
   :task (do
           (println "🛠️  Starting admin tools...")
           (p/shell "docker-compose --profile tools up -d")
           (println "\n🌐 Admin tools available:")
           (println "  pgAdmin:         http://localhost:8080 (admin@datacamp.local/admin)")
           (println "  phpMyAdmin:      http://localhost:8082 (root/password)")
           (println "  Redis Commander: http://localhost:8081"))}

  ;; Test tasks
  test:quick
  {:doc "Run quick tests (no external dependencies)"
   :task (p/shell "lein test datacamp.directory-test datacamp.integration-test")}

  test:all
  {:doc "Run all tests (starts/stops databases as needed)"
   :task (do
           (println "🔍 Checking database status...")
           (let [pg-was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-postgres")))
                 mysql-was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-mysql")))
                 redis-was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-redis")))
                 minio-was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-minio")))
                 services-to-start (cond-> []
                                     (not pg-was-running) (conj "postgres")
                                     (not mysql-was-running) (conj "mysql")
                                     (not redis-was-running) (conj "redis")
                                     (not minio-was-running) (conj "minio"))]
             (when (seq services-to-start)
               (println (str "🚀 Starting " (str/join ", " services-to-start) "..."))
               (p/shell (str "docker-compose up -d " (str/join " " services-to-start)))
               (println "⏳ Waiting for databases to be healthy...")
               (Thread/sleep 8000))
            (println "🧪 Running all tests...\n")
            (let [result (p/shell {:continue true} "lein test")
                  services-to-stop (cond-> []
                                      (not pg-was-running) (conj "postgres")
                                      (not mysql-was-running) (conj "mysql")
                                      (not redis-was-running) (conj "redis")
                                      (not minio-was-running) (conj "minio"))]
               (when (seq services-to-stop)
                 (println (str "\n⚙️ Stopping " (str/join ", " services-to-stop) "..."))
                 (p/shell (str "docker-compose stop " (str/join " " services-to-stop))))
               (when (not (zero? (:exit result)))
                 (System/exit 1)))))}


  test:directory
  {:doc "Run directory tests only"
   :task (p/shell "lein test datacamp.directory-test")}

  test:postgres
  {:doc "Run PostgreSQL tests (starts/stops postgres as needed)"
   :task (do
           (println "🔍 Checking postgres status...")
           (let [was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-postgres")))]
             (when (not was-running)
               (println "🚀 Starting postgres...")
               (p/shell "docker-compose up -d postgres")
               (println "⏳ Waiting for postgres to be healthy...")
               (Thread/sleep 5000))
             (println "🧪 Running PostgreSQL tests...\n")
             (let [result (p/shell {:continue true} "lein test datacamp.postgres-test")]
               (when (not was-running)
                 (println "\n⚙️ Stopping postgres...")
                 (p/shell "docker-compose stop postgres"))
               (when (not (zero? (:exit result)))
                 (System/exit 1)))))}


  test:mysql
  {:doc "Run MySQL tests (starts/stops mysql as needed)"
   :task (do
           (println "🔍 Checking mysql status...")
           (let [was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-mysql")))]
             (when (not was-running)
               (println "🚀 Starting mysql...")
               (p/shell "docker-compose up -d mysql")
               (println "⏳ Waiting for mysql to be healthy...")
               (Thread/sleep 8000))
             (println "🧪 Running MySQL tests...\n")
             (let [result (p/shell {:continue true} "lein test datacamp.mysql-test")]
               (when (not was-running)
                 (println "\n⚙️ Stopping mysql...")
                 (p/shell "docker-compose stop mysql"))
               (when (not (zero? (:exit result)))
                 (System/exit 1)))))}


  test:redis
  {:doc "Run Redis tests (starts/stops redis as needed)"
   :task (do
           (println "🔍 Checking redis status...")
           (let [was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-redis")))]
             (when (not was-running)
               (println "🚀 Starting redis...")
               (p/shell "docker-compose up -d redis")
               (println "⏳ Waiting for redis to be healthy...")
               (Thread/sleep 3000))
             (println "🧪 Running Redis tests...\n")
             (let [result (p/shell {:continue true} "lein test datacamp.redis-test")]
               (when (not was-running)
                 (println "\n⚙️ Stopping redis...")
                 (p/shell "docker-compose stop redis"))
               (when (not (zero? (:exit result)))
                 (System/exit 1)))))}


  test:integration
  {:doc "Run integration tests"
   :task (p/shell "lein test datacamp.integration-test")}

  test:complex
  {:doc "Run complex schema comparison test (starts/stops postgres as needed)"
   :task (do
           (println "🔍 Checking postgres status...")
           (let [was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-postgres")))]
             (when (not was-running)
               (println "🚀 Starting postgres...")
               (p/shell "docker-compose up -d postgres")
               (println "⏳ Waiting for postgres to be healthy...")
               (Thread/sleep 5000))
             (println "🧪 Running complex schema comparison test...\n")
             (let [result (p/shell {:continue true} "lein test datacamp.complex-test")]
               (when (not was-running)
                 (println "\n⚙️ Stopping postgres...")
                 (p/shell "docker-compose stop postgres"))
               (when (not (zero? (:exit result)))
                 (System/exit 1)))))}

  test:migration
  {:doc "Run migration tests including complex and error scenarios"
   :task (do
           (println "🚀 Running migration tests...")
           (println "This includes:")
           (println "  • Basic migration scenarios")
           (println "  • Complex migration with 120k entities")
           (println "  • Error handling and recovery tests")
           (println "  • Concurrent migration tests\n")
           (p/shell "lein test datacamp.migration-test"))}

  test:migration:complex
  {:doc "Run only the complex migration test with 120k entities"
   :task (do
           (println "🚀 Running complex migration test with 120k entities...")
           (println "This test will:")
           (println "  • Create 20,000 initial entities")
           (println "  • Write 10,000 entities/second for 10 seconds during migration")
           (println "  • Verify all 121,000+ entities are migrated correctly\n")
           (p/shell "lein test :only datacamp.migration-test/test-complex-migration-with-continuous-writes"))}

  test:migration:errors
  {:doc "Run only the migration error handling tests"
   :task (do
           (println "🚀 Running migration error handling tests...")
           (println "This test validates:")
           (println "  • Recovery from intermittent failures")
           (println "  • Network-like failures with retries")
           (println "  • State corruption recovery")
           (println "  • Concurrent migration blocking\n")
           (p/shell "lein test :only datacamp.migration-test/test-migration-error-handling"))}

  test:schema
  {:doc "Run schema evolution tests (no external dependencies)"
   :task (do
           (println "🧪 Running schema evolution tests...")
           (println "This test validates:")
           (println "  • Schema migration compatibility")
           (println "  • Cardinality changes (one to many)")
           (println "  • Unique constraint preservation")
           (println "  • Unique constraint removal")
           (println "  • Backup/restore with evolved schemas\n")
           (p/shell "lein test datacamp.schema-evolution-test"))}

  test:backend
  {:doc "Run all backend tests (starts/stops databases as needed)"
   :task (do
           (println "🔍 Checking database status...")
           (let [pg-was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-postgres")))
                 mysql-was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-mysql")))
                 redis-was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-redis")))
                 minio-was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-minio")))
                 services-to-start (cond-> []
                                     (not pg-was-running) (conj "postgres")
                                     (not mysql-was-running) (conj "mysql")
                                     (not redis-was-running) (conj "redis")
                                     (not minio-was-running) (conj "minio"))]
             (when (seq services-to-start)
               (println (str "🚀 Starting " (str/join ", " services-to-start) "..."))
               (p/shell (str "docker-compose up -d " (str/join " " services-to-start)))
               (println "⏳ Waiting for databases to be healthy...")
               (Thread/sleep 8000))
             (println "🧪 Running backend tests...\n")
             (let [result (p/shell {:continue true} "lein test datacamp.postgres-test datacamp.mysql-test datacamp.redis-test datacamp.s3-test")
                   services-to-stop (cond-> []
                                      (not pg-was-running) (conj "postgres")
                                      (not mysql-was-running) (conj "mysql")
                                      (not redis-was-running) (conj "redis")
                                      (not minio-was-running) (conj "minio"))]
               (when (seq services-to-stop)
                 (println (str "\n⚙️ Stopping " (str/join ", " services-to-stop) "..."))
                 (p/shell (str "docker-compose stop " (str/join " " services-to-stop))))
               (when (not (zero? (:exit result)))
                 (System/exit 1)))))}

  test:s3
  {:doc "Run S3 (MinIO) integration tests"
   :task (do
           (println "🔍 Checking MinIO status...")
           (let [was-running (= "true\n" (:out (p/shell {:out :string :continue true}
                                                      "docker inspect -f '{{.State.Running}}' datacamp-minio")))]
             (when (not was-running)
               (println "🚀 Starting MinIO...")
               (p/shell "docker-compose up -d minio")
               (println "⏳ Waiting for MinIO to be healthy...")
               (Thread/sleep 5000))
             (println "🧪 Running S3 integration tests...\n")
             (let [result (p/shell {:continue true}
                                   "lein test :only datacamp.s3-test/test-s3-backup-and-restore-roundtrip")]
               (when (not was-running)
                 (println "\n⚙️ Stopping MinIO...")
                 (p/shell "docker-compose stop minio"))
               (when (not (zero? (:exit result)))
                 (System/exit 1)))))}


  ;; Combined workflows
  test
  {:doc "Start Docker, run all tests, stop Docker (default)"
   :task (do
           (run 'docker:start)
           (Thread/sleep 8000)
           (println "\n🧪 Running tests...\n")
           (let [result (p/shell {:continue true} "lein test")]
             (println "\n⚙️ Stopping databases...")
             (run 'docker:stop)
             (when (not (zero? (:exit result)))
               (System/exit 1))))}

  test:with-docker
  {:doc "Alias for 'test' command"
   :task (run 'test)}

  ;; Development helpers
  repl
  {:doc "Start REPL with test databases"
   :task (do
           (println "Starting REPL with test environment...")
           (println "💡 Databases are available at:")
           (println "  PostgreSQL: localhost:5432")
           (println "  MySQL:      localhost:3306")
           (println "  Redis:      localhost:6379")
           (p/shell "lein repl"))}

  clean
  {:doc "Clean build artifacts"
   :task (p/shell "lein clean")}

  deps
  {:doc "Download dependencies"
   :task (p/shell "lein deps")}

  help
  {:doc "Show available tasks"
   :task (do
           (println "Datacamp Development Tasks")
           (println "==========================\n")
           (println "Quick Start:")
           (println "  bb test            - Run everything (start Docker, test, stop)")
           (println "\nDocker Management:")
           (println "  bb docker:start    - Start test databases")
           (println "  bb docker:stop     - Stop test databases")
           (println "  bb docker:restart  - Restart test databases")
           (println "  bb docker:reset    - Reset databases (delete data)")
           (println "  bb docker:status   - Check database status")
           (println "  bb docker:logs     - View database logs")
           (println "  bb docker:tools    - Start admin tools (pgAdmin, etc.)")
           (println "\nTesting:")
           (println "  bb test            - Complete workflow (recommended)")
           (println "  bb test:quick      - Quick tests (no databases needed)")
           (println "  bb test:all        - Run all tests")
           (println "  bb test:directory  - Directory backup tests")
           (println "  bb test:postgres   - PostgreSQL tests")
           (println "  bb test:mysql      - MySQL tests")
           (println "  bb test:redis      - Redis tests")
           (println "  bb test:backend    - All backend tests")
           (println "  bb test:integration - Integration tests")
           (println "  bb test:complex    - Complex schema comparison test")
           (println "  bb test:migration  - Migration tests (all scenarios)")
           (println "  bb test:migration:complex - Complex migration (120k entities)")
           (println "  bb test:migration:errors  - Error handling tests")
           (println "  bb test:schema     - Schema evolution tests")
           (println "\nDevelopment:")
           (println "  bb repl            - Start REPL")
           (println "  bb clean           - Clean build artifacts")
           (println "  bb deps            - Download dependencies")
           (println "\n💡 Use 'bb <task>' to run any task")
           (println "   Example: bb docker:start"))}}}
