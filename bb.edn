{:tasks
 {;; Docker environment tasks
  :requires ([babashka.process :as p]
             [clojure.string :as str])

  ;; Helper to detect docker compose command (v1 vs v2)
  :init (def docker-compose-cmd
          (if (zero? (:exit (p/shell {:out :string :err :string :continue true} "docker compose version")))
            "docker compose"
            "docker-compose"))

  docker:start
  {:doc "Start test database environment"
   :task (do
           (println "üöÄ Starting test databases...")
           (p/shell (str docker-compose-cmd " up -d postgres mysql redis localstack"))
           (println "\n‚è≥ Waiting for databases to be healthy...")
           (Thread/sleep 5000)
           (println "\n‚úÖ Databases started!")
           (println "\nConnection details:")
           (println "  PostgreSQL: localhost:5432 (postgres/postgres)")
           (println "  MySQL:      localhost:3306 (root/password)")
           (println "  Redis:      localhost:6379")
           (println "  LocalStack S3: http://localhost:4566 (test/test123)")
           (println "\nüí° Run 'bb docker:status' to check health"))}

  docker:stop
  {:doc "Stop test database environment"
   :task (do
           (println "Stopping test databases...")
           (p/shell (str docker-compose-cmd " down"))
           (println "‚úÖ Databases stopped"))}

  docker:restart
  {:doc "Restart test database environment"
   :task (do
           (run 'docker:stop)
           (Thread/sleep 2000)
           (run 'docker:start))}

  docker:reset
  {:doc "Reset databases (removes all data)"
   :task (do
           (println "‚ö†Ô∏è  This will delete all test data!")
           (print "Continue? (y/N): ")
           (flush)
           (let [input (str/lower-case (read-line))]
             (if (= input "y")
               (do
                 (println "\nüóëÔ∏è  Removing containers and volumes...")
                 (p/shell (str docker-compose-cmd " down -v"))
                 (Thread/sleep 2000)
                 (run 'docker:start))
               (println "Cancelled."))))}

  docker:status
  {:doc "Check status of test databases"
   :task (do
           (println "üìä Database Status\n==================\n")
           (p/shell (str docker-compose-cmd " ps"))
           (println "\nüí° Commands:")
           (println "  bb docker:start   - Start databases")
           (println "  bb docker:stop    - Stop databases")
           (println "  bb docker:restart - Restart databases")
           (println "  bb docker:reset   - Reset (delete all data)")
           (println "  bb docker:logs    - View logs"))}

  docker:logs
  {:doc "View database logs"
   :task (p/shell (str docker-compose-cmd " logs -f"))}

  docker:tools
  {:doc "Start database admin tools"
   :task (do
           (println "üõ†Ô∏è  Starting admin tools...")
           (p/shell (str docker-compose-cmd " --profile tools up -d"))
           (println "\nüåê Admin tools available:")
           (println "  pgAdmin:         http://localhost:8080 (admin@datacamp.local/admin)")
           (println "  phpMyAdmin:      http://localhost:8082 (root/password)")
           (println "  Redis Commander: http://localhost:8081"))}

  ;; Test tasks
  test:quick
  {:doc "Run quick tests (no external dependencies)"
   :task (p/shell "lein test datacamp.directory-test datacamp.integration-test")}

  test:all
  {:doc "Run all tests (starts/stops databases as needed)"
   :task (do
           (println "üîç Checking database status...")
           (let [pg-was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-postgres")))
                 mysql-was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-mysql")))
                 redis-was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-redis")))
                 localstack-was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-localstack")))
                 services-to-start (cond-> []
                                     (not pg-was-running) (conj "postgres")
                                     (not mysql-was-running) (conj "mysql")
                                     (not redis-was-running) (conj "redis")
                                     (not localstack-was-running) (conj "localstack"))]
             (when (seq services-to-start)
               (println (str "üöÄ Starting " (str/join ", " services-to-start) "..."))
               (p/shell (str docker-compose-cmd " up -d " (str/join " " services-to-start)))
               (println "‚è≥ Waiting for databases to be healthy...")
               (Thread/sleep 8000))
            (println "üß™ Running all tests...\n")
            (let [result (p/shell {:continue true} "lein test")
                  services-to-stop (cond-> []
                                      (not pg-was-running) (conj "postgres")
                                      (not mysql-was-running) (conj "mysql")
                                      (not redis-was-running) (conj "redis")
                                      (not localstack-was-running) (conj "localstack"))]
               (when (seq services-to-stop)
                 (println (str "\n‚öôÔ∏è Stopping " (str/join ", " services-to-stop) "..."))
                 (p/shell (str docker-compose-cmd " stop " (str/join " " services-to-stop))))
               (when (not (zero? (:exit result)))
                 (System/exit 1)))))}


  test:directory
  {:doc "Run directory tests only"
   :task (p/shell "lein test datacamp.directory-test")}

  test:postgres
  {:doc "Run PostgreSQL tests (starts/stops postgres as needed)"
   :task (do
           (println "üîç Checking postgres status...")
           (let [was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-postgres")))]
             (when (not was-running)
               (println "üöÄ Starting postgres...")
               (p/shell (str docker-compose-cmd " up -d postgres"))
               (println "‚è≥ Waiting for postgres to be healthy...")
               (Thread/sleep 5000))
             (println "üß™ Running PostgreSQL tests...\n")
             (let [result (p/shell {:continue true} "lein test datacamp.postgres-test")]
               (when (not was-running)
                 (println "\n‚öôÔ∏è Stopping postgres...")
                 (p/shell (str docker-compose-cmd " stop postgres")))
               (when (not (zero? (:exit result)))
                 (System/exit 1)))))}


  test:mysql
  {:doc "Run MySQL tests (starts/stops mysql as needed)"
   :task (do
           (println "üîç Checking mysql status...")
           (let [was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-mysql")))]
             (when (not was-running)
               (println "üöÄ Starting mysql...")
               (p/shell (str docker-compose-cmd " up -d mysql"))
               (println "‚è≥ Waiting for mysql to be healthy...")
               (Thread/sleep 8000))
             (println "üß™ Running MySQL tests...\n")
             (let [result (p/shell {:continue true} "lein test datacamp.mysql-test")]
               (when (not was-running)
                 (println "\n‚öôÔ∏è Stopping mysql...")
                 (p/shell (str docker-compose-cmd " stop mysql")))
               (when (not (zero? (:exit result)))
                 (System/exit 1)))))}


  test:redis
  {:doc "Run Redis tests (starts/stops redis as needed)"
   :task (do
           (println "üîç Checking redis status...")
           (let [was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-redis")))]
             (when (not was-running)
               (println "üöÄ Starting redis...")
               (p/shell (str docker-compose-cmd " up -d redis"))
               (println "‚è≥ Waiting for redis to be healthy...")
               (Thread/sleep 3000))
             (println "üß™ Running Redis tests...\n")
             (let [result (p/shell {:continue true} "lein test datacamp.redis-test")]
               (when (not was-running)
                 (println "\n‚öôÔ∏è Stopping redis...")
                 (p/shell (str docker-compose-cmd " stop redis")))
               (when (not (zero? (:exit result)))
                 (System/exit 1)))))}


  test:integration
  {:doc "Run integration tests"
   :task (p/shell "lein test datacamp.integration-test")}

  test:complex
  {:doc "Run complex schema comparison test (starts/stops postgres as needed)"
   :task (do
           (println "üîç Checking postgres status...")
           (let [was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-postgres")))]
             (when (not was-running)
               (println "üöÄ Starting postgres...")
               (p/shell (str docker-compose-cmd " up -d postgres"))
               (println "‚è≥ Waiting for postgres to be healthy...")
               (Thread/sleep 5000))
             (println "üß™ Running complex schema comparison test...\n")
             (let [result (p/shell {:continue true} "lein test datacamp.complex-test")]
               (when (not was-running)
                 (println "\n‚öôÔ∏è Stopping postgres...")
                 (p/shell (str docker-compose-cmd " stop postgres")))
               (when (not (zero? (:exit result)))
                 (System/exit 1)))))}

  test:migration
  {:doc "Run migration tests including complex and error scenarios"
   :task (do
           (println "üöÄ Running migration tests...")
           (println "This includes:")
           (println "  ‚Ä¢ Basic migration scenarios")
           (println "  ‚Ä¢ Complex migration with 120k entities")
           (println "  ‚Ä¢ Error handling and recovery tests")
           (println "  ‚Ä¢ Concurrent migration tests\n")
           (p/shell "lein test datacamp.migration-test"))}

  test:migration:complex
  {:doc "Run only the complex migration test with 120k entities"
   :task (do
           (println "üöÄ Running complex migration test with 120k entities...")
           (println "This test will:")
           (println "  ‚Ä¢ Create 20,000 initial entities")
           (println "  ‚Ä¢ Write 10,000 entities/second for 10 seconds during migration")
           (println "  ‚Ä¢ Verify all 121,000+ entities are migrated correctly\n")
           (p/shell "lein test :only datacamp.migration-test/test-complex-migration-with-continuous-writes"))}

  test:migration:errors
  {:doc "Run only the migration error handling tests"
   :task (do
           (println "üöÄ Running migration error handling tests...")
           (println "This test validates:")
           (println "  ‚Ä¢ Recovery from intermittent failures")
           (println "  ‚Ä¢ Network-like failures with retries")
           (println "  ‚Ä¢ State corruption recovery")
           (println "  ‚Ä¢ Concurrent migration blocking\n")
           (p/shell "lein test :only datacamp.migration-test/test-migration-error-handling"))}

  test:schema
  {:doc "Run schema evolution tests (no external dependencies)"
   :task (do
           (println "üß™ Running schema evolution tests...")
           (println "This test validates:")
           (println "  ‚Ä¢ Schema migration compatibility")
           (println "  ‚Ä¢ Cardinality changes (one to many)")
           (println "  ‚Ä¢ Unique constraint preservation")
           (println "  ‚Ä¢ Unique constraint removal")
           (println "  ‚Ä¢ Backup/restore with evolved schemas\n")
           (p/shell "lein test datacamp.schema-evolution-test"))}

  ;; Garbage Collection Tests
  test:gc
  {:doc "Run all garbage collection tests"
   :task (do
           (println "üóëÔ∏è  Running garbage collection tests...")
           (println "This includes:")
           (println "  ‚Ä¢ Core GC functionality tests")
           (println "  ‚Ä¢ Public API tests (datacamp.core/gc!)")
           (println "  ‚Ä¢ Batch operations tests\n")
           (let [result (p/shell {:continue true}
                               "lein test datacamp.gc-test datacamp.gc-core-api-test datacamp.konserve-extensions-test")]
             (when (not (zero? (:exit result)))
               (System/exit 1))))}

  test:gc:core
  {:doc "Run core GC functionality tests"
   :task (do
           (println "üóëÔ∏è  Running core GC tests...")
           (println "This test validates:")
           (println "  ‚Ä¢ Checkpoint save/load/resume")
           (println "  ‚Ä¢ GC status tracking")
           (println "  ‚Ä¢ Resumable marking phase")
           (println "  ‚Ä¢ Batch deletion sweep")
           (println "  ‚Ä¢ Retention policies\n")
           (let [result (p/shell {:continue true} "lein test datacamp.gc-test")]
             (when (not (zero? (:exit result)))
               (System/exit 1))))}

  test:gc:api
  {:doc "Run GC public API tests"
   :task (do
           (println "üóëÔ∏è  Running GC API tests...")
           (println "This test validates:")
           (println "  ‚Ä¢ datacamp.core/gc! function")
           (println "  ‚Ä¢ Safe dry-run defaults")
           (println "  ‚Ä¢ Auto-resume functionality")
           (println "  ‚Ä¢ Backend optimizations")
           (println "  ‚Ä¢ Error handling\n")
           (let [result (p/shell {:continue true} "lein test datacamp.gc-core-api-test")]
             (when (not (zero? (:exit result)))
               (System/exit 1))))}

  test:gc:batch
  {:doc "Run batch operations tests"
   :task (do
           (println "üóëÔ∏è  Running batch operations tests...")
           (println "This test validates:")
           (println "  ‚Ä¢ Batch dissoc, get, assoc operations")
           (println "  ‚Ä¢ Store extensions")
           (println "  ‚Ä¢ Backend-specific optimizations")
           (println "  ‚Ä¢ Fallback behavior\n")
           (let [result (p/shell {:continue true} "lein test datacamp.konserve-extensions-test")]
             (when (not (zero? (:exit result)))
               (System/exit 1))))}

  test:gc:stress
  {:doc "Run rigorous GC stress test (20 seconds, 150k+ datoms, concurrent writes)"
   :task (do
           (println "üóëÔ∏è  Running rigorous GC stress test...")
           (println "‚ö†Ô∏è  This test runs for ~20 seconds and writes ~150k datoms\n")
           (println "This test validates:")
           (println "  ‚Ä¢ 15k datoms per write in 3k batches")
           (println "  ‚Ä¢ 10 write iterations (every 2 seconds)")
           (println "  ‚Ä¢ 20 concurrent connections (every 1 second, 10 writes each)")
           (println "  ‚Ä¢ 100 early commits + 200 branch commits = ~300 unreachable commits")
           (println "  ‚Ä¢ Schema evolution during writes")
           (println "  ‚Ä¢ Multiple GC runs with different retention cutoffs")
           (println "  ‚Ä¢ :eavt datom count verification at each GC step")
           (println "  ‚Ä¢ Data integrity verification after GC")
           (println "  ‚Ä¢ Dry run vs actual deletion comparison\n")
           (let [result (p/shell {:continue true}
                               "lein test :only datacamp.gc-test/rigorous-gc-stress-test")]
             (when (not (zero? (:exit result)))
               (System/exit 1))))}

  test:backend
  {:doc "Run all backend tests (starts/stops databases as needed)"
   :task (do
           (println "üîç Checking database status...")
           (let [pg-was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-postgres")))
                 mysql-was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-mysql")))
                 redis-was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-redis")))
                 localstack-was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-localstack")))
                 services-to-start (cond-> []
                                     (not pg-was-running) (conj "postgres")
                                     (not mysql-was-running) (conj "mysql")
                                     (not redis-was-running) (conj "redis")
                                     (not localstack-was-running) (conj "localstack"))]
             (when (seq services-to-start)
               (println (str "üöÄ Starting " (str/join ", " services-to-start) "..."))
               (p/shell (str docker-compose-cmd " up -d " (str/join " " services-to-start)))
               (println "‚è≥ Waiting for databases to be healthy...")
               (Thread/sleep 8000))
             (println "üß™ Running backend tests...\n")
             (let [result (p/shell {:continue true} "lein test datacamp.postgres-test datacamp.mysql-test datacamp.redis-test datacamp.s3-test")
                   services-to-stop (cond-> []
                                      (not pg-was-running) (conj "postgres")
                                      (not mysql-was-running) (conj "mysql")
                                      (not redis-was-running) (conj "redis")
                                      (not localstack-was-running) (conj "localstack"))]
               (when (seq services-to-stop)
                 (println (str "\n‚öôÔ∏è Stopping " (str/join ", " services-to-stop) "..."))
                 (p/shell (str docker-compose-cmd " stop " (str/join " " services-to-stop))))
               (when (not (zero? (:exit result)))
                 (System/exit 1)))))}

  test:s3
  {:doc "Run S3 (LocalStack) integration tests"
   :task (do
           (println "üîç Checking LocalStack status...")
           (let [was-running (= "true\n" (:out (p/shell {:out :string :continue true}
                                                      "docker inspect -f '{{.State.Running}}' datacamp-localstack")))]
             (when (not was-running)
               (println "üöÄ Starting LocalStack...")
               (p/shell (str docker-compose-cmd " up -d localstack"))
               (println "‚è≥ Waiting for LocalStack to be healthy...")
               (Thread/sleep 5000))
             (println "üß™ Running S3 integration tests...\n")
             (let [result (p/shell {:continue true}
                                   "lein test :only datacamp.s3-test/test-s3-backup-and-restore-roundtrip")]
               (when (not was-running)
                 (println "\n‚öôÔ∏è Stopping LocalStack...")
                 (p/shell (str docker-compose-cmd " stop localstack")))
               (when (not (zero? (:exit result)))
                 (System/exit 1)))))}


  ;; Coverage
  coverage
  {:doc "Run code coverage with cloverage (starts/stops databases as needed)"
   :task (do
           (println "üîç Checking database status...")
           (let [pg-was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-postgres")))
                 mysql-was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-mysql")))
                 redis-was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-redis")))
                 localstack-was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-localstack")))
                 services-to-start (cond-> []
                                     (not pg-was-running) (conj "postgres")
                                     (not mysql-was-running) (conj "mysql")
                                     (not redis-was-running) (conj "redis")
                                     (not localstack-was-running) (conj "localstack"))
                 extra-args (str/join " " *command-line-args*)]
             (when (seq services-to-start)
               (println (str "üöÄ Starting " (str/join ", " services-to-start) "..."))
               (p/shell (str docker-compose-cmd " up -d " (str/join " " services-to-start)))
               (println "‚è≥ Waiting for databases to be healthy...")
               (Thread/sleep 8000))
             (println "üìä Running code coverage analysis...\n")
             (let [result (p/shell {:continue true} (str "lein cloverage " extra-args))
                   services-to-stop (cond-> []
                                      (not pg-was-running) (conj "postgres")
                                      (not mysql-was-running) (conj "mysql")
                                      (not redis-was-running) (conj "redis")
                                      (not localstack-was-running) (conj "localstack"))]
               (when (seq services-to-stop)
                 (println (str "\n‚öôÔ∏è Stopping " (str/join ", " services-to-stop) "..."))
                 (p/shell (str docker-compose-cmd " stop " (str/join " " services-to-stop))))
               (when (zero? (:exit result))
                 (println "\n‚úÖ Coverage report generated!")
                 (println "üìÑ View HTML report: target/coverage/index.html"))
               (when (not (zero? (:exit result)))
                 (System/exit 1)))))}

  ;; Combined workflows
  test
  {:doc "Start Docker, run all tests, stop Docker (default)"
   :task (do
           (run 'docker:start)
           (Thread/sleep 8000)
           (println "\nüß™ Running tests...\n")
           (let [result (p/shell {:continue true} "lein test")]
             (println "\n‚öôÔ∏è Stopping databases...")
             (run 'docker:stop)
             (when (not (zero? (:exit result)))
               (System/exit 1))))}

  test:with-docker
  {:doc "Alias for 'test' command"
   :task (run 'test)}

  ;; Development helpers
  repl
  {:doc "Start REPL with test databases"
   :task (do
           (println "Starting REPL with test environment...")
           (println "üí° Databases are available at:")
           (println "  PostgreSQL: localhost:5432")
           (println "  MySQL:      localhost:3306")
           (println "  Redis:      localhost:6379")
           (p/shell "lein repl"))}

  clean
  {:doc "Clean build artifacts"
   :task (p/shell "lein clean")}

  deps
  {:doc "Download dependencies"
   :task (p/shell "lein deps")}

  help
  {:doc "Show available tasks"
   :task (do
           (println "Datacamp Development Tasks")
           (println "==========================\n")
           (println "Quick Start:")
           (println "  bb test            - Run everything (start Docker, test, stop)")
           (println "\nDocker Management:")
           (println "  bb docker:start    - Start test databases")
           (println "  bb docker:stop     - Stop test databases")
           (println "  bb docker:restart  - Restart test databases")
           (println "  bb docker:reset    - Reset databases (delete data)")
           (println "  bb docker:status   - Check database status")
           (println "  bb docker:logs     - View database logs")
           (println "  bb docker:tools    - Start admin tools (pgAdmin, etc.)")
           (println "\nTesting:")
           (println "  bb test            - Complete workflow (recommended)")
           (println "  bb test:quick      - Quick tests (no databases needed)")
           (println "  bb test:all        - Run all tests")
           (println "  bb test:directory  - Directory backup tests")
           (println "  bb test:postgres   - PostgreSQL tests")
           (println "  bb test:mysql      - MySQL tests")
           (println "  bb test:redis      - Redis tests")
           (println "  bb test:backend    - All backend tests")
           (println "  bb test:integration - Integration tests")
           (println "  bb test:complex    - Complex schema comparison test")
           (println "  bb test:migration  - Migration tests (all scenarios)")
           (println "  bb test:migration:complex - Complex migration (120k entities)")
           (println "  bb test:migration:errors  - Error handling tests")
           (println "  bb test:schema     - Schema evolution tests")
           (println "  bb test:gc         - All garbage collection tests")
           (println "  bb test:gc:core    - Core GC functionality tests")
           (println "  bb test:gc:api     - GC public API tests")
           (println "  bb test:gc:batch   - Batch operations tests")
           (println "\nCode Coverage:")
           (println "  bb coverage        - Run code coverage analysis with cloverage")
           (println "\nDevelopment:")
           (println "  bb repl            - Start REPL")
           (println "  bb clean           - Clean build artifacts")
           (println "  bb deps            - Download dependencies")
           (println "\nüí° Use 'bb <task>' to run any task")
           (println "   Example: bb docker:start"))}}}
