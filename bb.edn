{:tasks
 {;; Docker environment tasks
  :requires ([babashka.process :as p]
             [clojure.string :as str])

  docker:start
  {:doc "Start test database environment"
   :task (do
           (println "ğŸš€ Starting test databases...")
           (p/shell "docker-compose up -d postgres mysql redis minio")
           (println "\nâ³ Waiting for databases to be healthy...")
           (Thread/sleep 5000)
           (println "\nâœ… Databases started!")
           (println "\nConnection details:")
           (println "  PostgreSQL: localhost:5432 (postgres/postgres)")
           (println "  MySQL:      localhost:3306 (root/password)")
           (println "  Redis:      localhost:6379")
           (println "  MinIO S3:   http://localhost:9000 (minioadmin/minioadmin)")
           (println "\nğŸ’¡ Run 'bb docker:status' to check health"))}

  docker:stop
  {:doc "Stop test database environment"
   :task (do
           (println "Stopping test databases...")
           (p/shell "docker-compose down")
           (println "âœ… Databases stopped"))}

  docker:restart
  {:doc "Restart test database environment"
   :task (do
           (run 'docker:stop)
           (Thread/sleep 2000)
           (run 'docker:start))}

  docker:reset
  {:doc "Reset databases (removes all data)"
   :task (do
           (println "âš ï¸  This will delete all test data!")
           (print "Continue? (y/N): ")
           (flush)
           (let [input (str/lower-case (read-line))]
             (if (= input "y")
               (do
                 (println "\nğŸ—‘ï¸  Removing containers and volumes...")
                 (p/shell "docker-compose down -v")
                 (Thread/sleep 2000)
                 (run 'docker:start))
               (println "Cancelled."))))}

  docker:status
  {:doc "Check status of test databases"
   :task (do
           (println "ğŸ“Š Database Status\n==================\n")
           (p/shell "docker-compose ps")
           (println "\nğŸ’¡ Commands:")
           (println "  bb docker:start   - Start databases")
           (println "  bb docker:stop    - Stop databases")
           (println "  bb docker:restart - Restart databases")
           (println "  bb docker:reset   - Reset (delete all data)")
           (println "  bb docker:logs    - View logs"))}

  docker:logs
  {:doc "View database logs"
   :task (p/shell "docker-compose logs -f")}

  docker:tools
  {:doc "Start database admin tools"
   :task (do
           (println "ğŸ› ï¸  Starting admin tools...")
           (p/shell "docker-compose --profile tools up -d")
           (println "\nğŸŒ Admin tools available:")
           (println "  pgAdmin:         http://localhost:8080 (admin@datacamp.local/admin)")
           (println "  phpMyAdmin:      http://localhost:8082 (root/password)")
           (println "  Redis Commander: http://localhost:8081"))}

  ;; Test tasks
  test:quick
  {:doc "Run quick tests (no external dependencies)"
   :task (p/shell "lein test datacamp.directory-test datacamp.integration-test")}

  test:all
  {:doc "Run all tests (starts/stops databases as needed)"
   :task (do
           (println "ğŸ” Checking database status...")
           (let [pg-was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-postgres")))
                 mysql-was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-mysql")))
                 redis-was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-redis")))
                 minio-was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-minio")))
                 services-to-start (cond-> []
                                     (not pg-was-running) (conj "postgres")
                                     (not mysql-was-running) (conj "mysql")
                                     (not redis-was-running) (conj "redis")
                                     (not minio-was-running) (conj "minio"))]
             (when (seq services-to-start)
               (println (str "ğŸš€ Starting " (str/join ", " services-to-start) "..."))
               (p/shell (str "docker-compose up -d " (str/join " " services-to-start)))
               (println "â³ Waiting for databases to be healthy...")
               (Thread/sleep 8000))
            (println "ğŸ§ª Running all tests...\n")
            (let [result (p/shell {:continue true} "lein test")
                  services-to-stop (cond-> []
                                      (not pg-was-running) (conj "postgres")
                                      (not mysql-was-running) (conj "mysql")
                                      (not redis-was-running) (conj "redis")
                                      (not minio-was-running) (conj "minio"))]
               (when (seq services-to-stop)
                 (println (str "\nâš™ï¸ Stopping " (str/join ", " services-to-stop) "..."))
                 (p/shell (str "docker-compose stop " (str/join " " services-to-stop))))
               (when (not (zero? (:exit result)))
                 (System/exit 1)))))}


  test:directory
  {:doc "Run directory tests only"
   :task (p/shell "lein test datacamp.directory-test")}

  test:postgres
  {:doc "Run PostgreSQL tests (starts/stops postgres as needed)"
   :task (do
           (println "ğŸ” Checking postgres status...")
           (let [was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-postgres")))]
             (when (not was-running)
               (println "ğŸš€ Starting postgres...")
               (p/shell "docker-compose up -d postgres")
               (println "â³ Waiting for postgres to be healthy...")
               (Thread/sleep 5000))
             (println "ğŸ§ª Running PostgreSQL tests...\n")
             (let [result (p/shell {:continue true} "lein test datacamp.postgres-test")]
               (when (not was-running)
                 (println "\nâš™ï¸ Stopping postgres...")
                 (p/shell "docker-compose stop postgres"))
               (when (not (zero? (:exit result)))
                 (System/exit 1)))))}


  test:mysql
  {:doc "Run MySQL tests (starts/stops mysql as needed)"
   :task (do
           (println "ğŸ” Checking mysql status...")
           (let [was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-mysql")))]
             (when (not was-running)
               (println "ğŸš€ Starting mysql...")
               (p/shell "docker-compose up -d mysql")
               (println "â³ Waiting for mysql to be healthy...")
               (Thread/sleep 8000))
             (println "ğŸ§ª Running MySQL tests...\n")
             (let [result (p/shell {:continue true} "lein test datacamp.mysql-test")]
               (when (not was-running)
                 (println "\nâš™ï¸ Stopping mysql...")
                 (p/shell "docker-compose stop mysql"))
               (when (not (zero? (:exit result)))
                 (System/exit 1)))))}


  test:redis
  {:doc "Run Redis tests (starts/stops redis as needed)"
   :task (do
           (println "ğŸ” Checking redis status...")
           (let [was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-redis")))]
             (when (not was-running)
               (println "ğŸš€ Starting redis...")
               (p/shell "docker-compose up -d redis")
               (println "â³ Waiting for redis to be healthy...")
               (Thread/sleep 3000))
             (println "ğŸ§ª Running Redis tests...\n")
             (let [result (p/shell {:continue true} "lein test datacamp.redis-test")]
               (when (not was-running)
                 (println "\nâš™ï¸ Stopping redis...")
                 (p/shell "docker-compose stop redis"))
               (when (not (zero? (:exit result)))
                 (System/exit 1)))))}


  test:integration
  {:doc "Run integration tests"
   :task (p/shell "lein test datacamp.integration-test")}

  test:complex
  {:doc "Run complex schema comparison test (starts/stops postgres as needed)"
   :task (do
           (println "ğŸ” Checking postgres status...")
           (let [was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-postgres")))]
             (when (not was-running)
               (println "ğŸš€ Starting postgres...")
               (p/shell "docker-compose up -d postgres")
               (println "â³ Waiting for postgres to be healthy...")
               (Thread/sleep 5000))
             (println "ğŸ§ª Running complex schema comparison test...\n")
             (let [result (p/shell {:continue true} "lein test datacamp.complex-test")]
               (when (not was-running)
                 (println "\nâš™ï¸ Stopping postgres...")
                 (p/shell "docker-compose stop postgres"))
               (when (not (zero? (:exit result)))
                 (System/exit 1)))))}

  test:migration
  {:doc "Run migration tests including complex and error scenarios"
   :task (do
           (println "ğŸš€ Running migration tests...")
           (println "This includes:")
           (println "  â€¢ Basic migration scenarios")
           (println "  â€¢ Complex migration with 120k entities")
           (println "  â€¢ Error handling and recovery tests")
           (println "  â€¢ Concurrent migration tests\n")
           (p/shell "lein test datacamp.migration-test"))}

  test:migration:complex
  {:doc "Run only the complex migration test with 120k entities"
   :task (do
           (println "ğŸš€ Running complex migration test with 120k entities...")
           (println "This test will:")
           (println "  â€¢ Create 20,000 initial entities")
           (println "  â€¢ Write 10,000 entities/second for 10 seconds during migration")
           (println "  â€¢ Verify all 121,000+ entities are migrated correctly\n")
           (p/shell "lein test :only datacamp.migration-test/test-complex-migration-with-continuous-writes"))}

  test:migration:errors
  {:doc "Run only the migration error handling tests"
   :task (do
           (println "ğŸš€ Running migration error handling tests...")
           (println "This test validates:")
           (println "  â€¢ Recovery from intermittent failures")
           (println "  â€¢ Network-like failures with retries")
           (println "  â€¢ State corruption recovery")
           (println "  â€¢ Concurrent migration blocking\n")
           (p/shell "lein test :only datacamp.migration-test/test-migration-error-handling"))}

  test:schema
  {:doc "Run schema evolution tests (no external dependencies)"
   :task (do
           (println "ğŸ§ª Running schema evolution tests...")
           (println "This test validates:")
           (println "  â€¢ Schema migration compatibility")
           (println "  â€¢ Cardinality changes (one to many)")
           (println "  â€¢ Unique constraint preservation")
           (println "  â€¢ Unique constraint removal")
           (println "  â€¢ Backup/restore with evolved schemas\n")
           (p/shell "lein test datacamp.schema-evolution-test"))}

  test:backend
  {:doc "Run all backend tests (starts/stops databases as needed)"
   :task (do
           (println "ğŸ” Checking database status...")
           (let [pg-was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-postgres")))
                 mysql-was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-mysql")))
                 redis-was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-redis")))
                 minio-was-running (= "true\n" (:out (p/shell {:out :string :continue true} "docker inspect -f '{{.State.Running}}' datacamp-minio")))
                 services-to-start (cond-> []
                                     (not pg-was-running) (conj "postgres")
                                     (not mysql-was-running) (conj "mysql")
                                     (not redis-was-running) (conj "redis")
                                     (not minio-was-running) (conj "minio"))]
             (when (seq services-to-start)
               (println (str "ğŸš€ Starting " (str/join ", " services-to-start) "..."))
               (p/shell (str "docker-compose up -d " (str/join " " services-to-start)))
               (println "â³ Waiting for databases to be healthy...")
               (Thread/sleep 8000))
             (println "ğŸ§ª Running backend tests...\n")
             (let [result (p/shell {:continue true} "lein test datacamp.postgres-test datacamp.mysql-test datacamp.redis-test datacamp.s3-test")
                   services-to-stop (cond-> []
                                      (not pg-was-running) (conj "postgres")
                                      (not mysql-was-running) (conj "mysql")
                                      (not redis-was-running) (conj "redis")
                                      (not minio-was-running) (conj "minio"))]
               (when (seq services-to-stop)
                 (println (str "\nâš™ï¸ Stopping " (str/join ", " services-to-stop) "..."))
                 (p/shell (str "docker-compose stop " (str/join " " services-to-stop))))
               (when (not (zero? (:exit result)))
                 (System/exit 1)))))}

  test:s3
  {:doc "Run S3 (MinIO) integration tests"
   :task (do
           (println "ğŸ” Checking MinIO status...")
           (let [was-running (= "true\n" (:out (p/shell {:out :string :continue true}
                                                      "docker inspect -f '{{.State.Running}}' datacamp-minio")))]
             (when (not was-running)
               (println "ğŸš€ Starting MinIO...")
               (p/shell "docker-compose up -d minio")
               (println "â³ Waiting for MinIO to be healthy...")
               (Thread/sleep 5000))
             (println "ğŸ§ª Running S3 integration tests...\n")
             (let [result (p/shell {:continue true}
                                   "lein test :only datacamp.s3-test/test-s3-backup-and-restore-roundtrip")]
               (when (not was-running)
                 (println "\nâš™ï¸ Stopping MinIO...")
                 (p/shell "docker-compose stop minio"))
               (when (not (zero? (:exit result)))
                 (System/exit 1)))))}


  ;; Combined workflows
  test
  {:doc "Start Docker, run all tests, stop Docker (default)"
   :task (do
           (run 'docker:start)
           (Thread/sleep 8000)
           (println "\nğŸ§ª Running tests...\n")
           (let [result (p/shell {:continue true} "lein test")]
             (println "\nâš™ï¸ Stopping databases...")
             (run 'docker:stop)
             (when (not (zero? (:exit result)))
               (System/exit 1))))}

  test:with-docker
  {:doc "Alias for 'test' command"
   :task (run 'test)}

  ;; Development helpers
  repl
  {:doc "Start REPL with test databases"
   :task (do
           (println "Starting REPL with test environment...")
           (println "ğŸ’¡ Databases are available at:")
           (println "  PostgreSQL: localhost:5432")
           (println "  MySQL:      localhost:3306")
           (println "  Redis:      localhost:6379")
           (p/shell "lein repl"))}

  clean
  {:doc "Clean build artifacts"
   :task (p/shell "lein clean")}

  deps
  {:doc "Download dependencies"
   :task (p/shell "lein deps")}

  help
  {:doc "Show available tasks"
   :task (do
           (println "Datacamp Development Tasks")
           (println "==========================\n")
           (println "Quick Start:")
           (println "  bb test            - Run everything (start Docker, test, stop)")
           (println "\nDocker Management:")
           (println "  bb docker:start    - Start test databases")
           (println "  bb docker:stop     - Stop test databases")
           (println "  bb docker:restart  - Restart test databases")
           (println "  bb docker:reset    - Reset databases (delete data)")
           (println "  bb docker:status   - Check database status")
           (println "  bb docker:logs     - View database logs")
           (println "  bb docker:tools    - Start admin tools (pgAdmin, etc.)")
           (println "\nTesting:")
           (println "  bb test            - Complete workflow (recommended)")
           (println "  bb test:quick      - Quick tests (no databases needed)")
           (println "  bb test:all        - Run all tests")
           (println "  bb test:directory  - Directory backup tests")
           (println "  bb test:postgres   - PostgreSQL tests")
           (println "  bb test:mysql      - MySQL tests")
           (println "  bb test:redis      - Redis tests")
           (println "  bb test:backend    - All backend tests")
           (println "  bb test:integration - Integration tests")
           (println "  bb test:complex    - Complex schema comparison test")
           (println "  bb test:migration  - Migration tests (all scenarios)")
           (println "  bb test:migration:complex - Complex migration (120k entities)")
           (println "  bb test:migration:errors  - Error handling tests")
           (println "  bb test:schema     - Schema evolution tests")
           (println "\nDevelopment:")
           (println "  bb repl            - Start REPL")
           (println "  bb clean           - Clean build artifacts")
           (println "  bb deps            - Download dependencies")
           (println "\nğŸ’¡ Use 'bb <task>' to run any task")
           (println "   Example: bb docker:start"))}}}
